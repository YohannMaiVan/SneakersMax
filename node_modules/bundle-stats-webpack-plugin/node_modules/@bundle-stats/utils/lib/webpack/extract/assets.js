"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractAssets = void 0;

require("core-js/modules/es.array.flat.js");

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const IGNORE_PATTERN = /\.(map|LICENSE\.txt)$/;

const extractAssets = webpackStats => {
  const webpackAssets = (0, _get2.default)(webpackStats, 'assets', []);
  const webpackChunks = (0, _get2.default)(webpackStats, 'chunks', []);
  const webpackEntrypoints = (0, _get2.default)(webpackStats, 'entrypoints', {});
  const entryItems = Object.values(webpackEntrypoints).map(({
    assets: items
  }) => items).flat();
  const initialItems = webpackChunks.filter(({
    initial
  }) => initial).map(({
    files
  }) => files).flat();
  const normalizedChunks = webpackChunks.map(({
    id,
    names,
    files
  }) => ({
    id: id.toString(),
    name: names.join('+') || `chunk-${id}`,
    files
  }));
  const assets = webpackAssets.reduce((aggregator, asset) => {
    const baseName = asset === null || asset === void 0 ? void 0 : asset.name.split('?')[0];

    if (IGNORE_PATTERN.test(baseName)) {
      return aggregator;
    } // Check for the corresponding chunk


    const assetChunk = normalizedChunks.find(chunk => chunk.files.includes(asset.name));
    const normalizedName = (0, _utils.getAssetName)(baseName);
    const {
      size,
      name
    } = asset;
    return _objectSpread(_objectSpread({}, aggregator), {}, {
      [normalizedName]: _objectSpread({
        name: baseName,
        value: size,
        isEntry: entryItems.includes(name),
        isInitial: initialItems.includes(name),
        isChunk: Boolean(assetChunk)
      }, assetChunk ? {
        chunkId: assetChunk.id
      } : {})
    });
  }, {});
  return _objectSpread({
    metrics: {
      assets
    }
  }, !(0, _isEmpty2.default)(normalizedChunks) ? {
    meta: {
      chunks: normalizedChunks.map(({
        id,
        name
      }) => ({
        id,
        name
      }))
    }
  } : {});
};

exports.extractAssets = extractAssets;