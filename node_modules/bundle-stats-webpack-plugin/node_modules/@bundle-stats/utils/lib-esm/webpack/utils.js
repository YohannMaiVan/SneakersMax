"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMetricType = exports.getMetricDeleted = exports.getMetricAdded = exports.calculateCacheInvalidation = exports.getModuleName = exports.getAssetName = void 0;

require("core-js/modules/es.string.replace.js");

require("core-js/modules/es.string.trim.js");

require("core-js/modules/es.array.iterator.js");

var _round2 = _interopRequireDefault(require("lodash/round"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _last2 = _interopRequireDefault(require("lodash/last"));

var _metrics = require("../utils/metrics");

var _metrics2 = require("./metrics");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Md5 hash matcher
const HASH_PATTERN = '[a-f|0-9]{7,32}'; // Match has prefix

const HASH_SEPARATOR_PATTERN = '[-|.]'; // Match multiple extensions: .js, .js.gz, .min.js, .chunk.js

const EXTENSION_PATTERN = /(?:\.[a-z|0-9]{2,}){1,}/;
const PATTERNS = [// Match path/name-HASH.ext, path/name.HASH.ext, path/name-HASH.chunk.ext
`(.*)${HASH_SEPARATOR_PATTERN}${HASH_PATTERN}(${EXTENSION_PATTERN.source})$`, // Match static/HASH
`(static)/${HASH_PATTERN}(.*${EXTENSION_PATTERN.source})$`].map(pattern => new RegExp(pattern));
const NO_BASENAME = /(^|.*\/)\..*$/;
/**
 * Extract (guess) filename from a hashed filename
 */

const getAssetName = assetFilepath => {
  if (!assetFilepath) {
    return '';
  }

  let result;

  for (let i = 0; i < PATTERNS.length && !result; i += 1) {
    const pattern = PATTERNS[i];
    const extracted = assetFilepath.replace(pattern, '$1$2');

    if (extracted && extracted !== assetFilepath && !NO_BASENAME.test(extracted)) {
      result = extracted;
    }
  }

  if (!result) {
    return assetFilepath;
  }

  return result;
}; // css ./node_modules/css-loader/dist/cjs.js??ref--6-0!./src/assets/styles/default.styl


exports.getAssetName = getAssetName;
const NAME_WITH_LOADERS = /!/; // ./src/index.jsx + 27 modules

const NAME_WITH_MODULES = /\s\+\s\d*\smodules$/;

const getModuleName = moduleLabel => {
  if (!moduleLabel) {
    return '';
  }

  if (NAME_WITH_LOADERS.test(moduleLabel)) {
    const normalizedName = (0, _last2.default)(moduleLabel.split(NAME_WITH_LOADERS));

    if (normalizedName !== null && normalizedName !== void 0 && normalizedName.trim()) {
      return normalizedName;
    }
  }

  if (NAME_WITH_MODULES.test(moduleLabel)) {
    return moduleLabel.replace(NAME_WITH_MODULES, '');
  }

  return moduleLabel;
};
/*
 * Calculate cache invalidation metric on the baseline data
 *
 * The metric is the ratio between the total file size of the files that have changed (exclude
 * deleted, added) and the total file size
 */


exports.getModuleName = getModuleName;

const calculateCacheInvalidation = rows => {
  let cached = 0;
  let invalidated = 0;
  rows.forEach(({
    changed,
    added,
    deleted,
    runs
  }) => {
    // Added and deleted files do not count towards the caching index
    if (added || deleted) {
      return;
    }

    if (changed) {
      invalidated += runs[1].value;
    }

    cached += runs[1].value;
  });

  if (cached === 0) {
    return 0;
  }

  return (0, _round2.default)(invalidated / cached * 100, 2);
};

exports.calculateCacheInvalidation = calculateCacheInvalidation;

const getMetricAdded = runs => {
  const [current, baseline] = (0, _map2.default)(runs, 'value');
  return Boolean(current !== null && !baseline);
};

exports.getMetricAdded = getMetricAdded;

const getMetricDeleted = runs => {
  const [current, baseline] = (0, _map2.default)(runs, 'value');
  return Boolean(baseline !== null && !current);
};
/**
 * Get webpack metric data
 *
 * @param {String} key - Webpack metric key
 * @return {Object} Metric data
 */


exports.getMetricDeleted = getMetricDeleted;
const getMetricType = (0, _metrics.createGetMetricType)(_metrics2.metrics);
exports.getMetricType = getMetricType;